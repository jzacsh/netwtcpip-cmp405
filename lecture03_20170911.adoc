== lecture 20170911: "IP Protocol"
:hw2ipdatagram: http://comet.lehman.cuny.edu/sfakhouri/teaching/cmp/cmp405/f17/hw/hw2-ipframe.png
:slides: http://comet.lehman.cuny.edu/sfakhouri/teaching/cmp/cmp405/f17/lecturenotes/Chapter%206.pdf

NOTE: {slides}[slides for this lecture]

connectionless packet delivery service
robust

.3 big takeaways
1. internet addressing scheme
2. formats packets
3. routing; ie: packet-forwarding

"packet" == "network packet" == "ip datagram"

.datagram layout
header:: src addr, dest addr, datagram type
data:: payload (comes from layer above IP)


.datagram header layout
|===
| field | byte length | notes
| version | 1/2: 4 bits | eg: `4` == `0100` for ipv4
| header-leng | 1/2: 4 bits | # of rows; ie: total-len / 2 ; our purposes, usually `5`
| type of service | 1 |
| total length | 2 | total byte-length of *header plus payload*
| ident | |
| flags | |
| fragment offset | |
| TTL (time to live) | | usually `225`, ie: `FF`; min-num hops <1>
| type | | 
| header checksum | |
| source ip addr | |
| dest ip addr | |
| skipped | |
| payload/data | | ie: these are first bytes *not* part of header layout
|===
<1> routers decrement TTL value; TTL=0, then packet dropped

NOTE: tcp/ip error handling: detector of errors send back to original sender

.ethernet frame headers:
. 14 bytes
. src hrdwr addr=`0000` (ie: "ip layer gave me this")
. dst hrdw addr
. frame type=`0800` (ie: "ip datagram")

=== mtu & datagram fragmentation

WARN: MTU (max transmission unit) is 1500bytes is a property of NETWORK (ethernet) not of machine or routers

question: what else is there, if everyone is using ethernet? (even wifi/bluetooth)

solution to mtu problem:
 datagram fragmentation send 

mtu applies to the *frame data* size, not the frame itself

question: 64k = 65k535 = 2^16 - 1
  what is this referring to?
  
set fragment offset field of chunked payloads to be equal to the
byte-number (zero-indexed) of the payload within the larger picture of bytes being sent

indicate end-of chunking stream by setting *fragment flag* to `0`
(instead of `1` for "more coming after me")

after first chunk arrives, we set a timer; if *all* fragments don't arrive by time,
then dump everything & return error message

*identification* 2-byte field of ip datagram explains to *which* stream
of chunks a chunk belongs

.fragment flag & offset fields:
flags:: 3 bits
.. 0: reserved, unused
.. dnf (do not forward)
.. more
offset index: 16-3 bits = 13bits; max-index = 2^13 - 1



== hw #2 scratch work

scratch work done for hw #2 while waiting for lecture to start

NOTE: ocr detected free online, for {hw2ipdatagram}[hw 2's ip datagram]

.original
----
C4 BC 6E 3A 5C E7 B9 AA B8 AO OF C3 08 00 45 F9
00 72 E4 D2 78 01 83 CD EB 40 CC 51 2D BB B3 DC
88 4D 41 8E B7 C2 CB 95 C9 68 BD 7B D2 3F D6 DD 
OF 28 20 DD 21 FO ED 32 27 F1 50 3F 89 04 C7 2A 
F2 34 CC D9 34 71 35 F4 98 74 06 BA 93 32 11 E0 
54 06 90 FA 85 FE DF 78 C1 B9 E6 5A 93 75 1C AD
FB 88 10 C2 AA 5F C5 7D 93 97 C1 62 94 3B 89 7F
FC 34 BB 4B 27 6D 92 6C 46 75 OA 86 40 37 4B CA
----

.wrapped at 4 bytes
----
C4 BC 6E 3A
5C E7       # <1>
      B9 AA
B8 AO OF C3 # <2>
08 00       # <3>

            # <4>
      45    # <5>
         F9 # <6>
00 72       # <7>
      E4 D2 # <8> 
7           # <9>
 8 01 83 CD # <10>
EB          # <11>
   40       # <12>
      CC 51 # <13>
2D BB B3 DC # <14>
88 4D 41 8E # <15>
            # <19>
B7 C2 CB 95
C9 68 BD 7B
D2 3F D6 DD
OF 28 20 DD
21 FO ED 32
27 F1 50 3F
89 04 C7 2A
F2 34 CC D9
34 71 35 F4
98 74 06 BA
93 32 11 E0
54 06 90 FA
85 FE DF 78
C1 B9 E6 5A
93 75 1C AD
FB 88 10 C2
AA 5F C5 7D
93 97 C1 62
94 3B 89 7F
FC 34 BB 4B
27 6D 92 6C
46 75 OA 86
40 37 4B CA
----
<1> frame: end of dst hw address
<2> frame: end of src hw address
<3> frame: end of frame type
<4> "ip datagram" ie: start of "frame data" 46-1500 bytes
<5> version & hlen
<6> type of service
<7> total length including payload
<8> identification
<9> fragment flags
<10> fragment offset
<11> ttl
<12> type
<13> header checksum
<14> src ip address
<15> dest ip address
<19> end of ip datagram header
